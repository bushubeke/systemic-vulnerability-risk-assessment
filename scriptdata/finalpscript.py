#!/usr/bin/env python
# coding: utf-8

# In[1]:


import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from cvss import CVSS3
from itertools import product
import math
from functools import reduce
import operator
import re


# # creating NVD Database data, scanning data dataframe

# In[2]:


nvddata=pd.read_csv('/home/Bushu/Documents/Enviroment/allen/data/nvdwithmissng.csv',header="infer")
#nvddata=nvddata[nvddata.cvss_scorev3 != 'nov3']
nvddata=nvddata.iloc[:,[0,1,3,6,7,]]
targetdata=pd.read_csv('/home/Bushu/Documents/Enviroment/allen/data/mainscan/targetresult.csv')
threatdata=pd.read_csv('/home/Bushu/Documents/Enviroment/allen/data/mainscan/threatresult.csv')
cwe_patterns=pd.read_csv('/home/Bushu/Documents/Enviroment/allen/data/cwelist.csv')
# data=pd.read_csv('/home/Bushu/Documents/Final Paper/data/nvd2021e.csv',header="infer")
#https://www.cvedetails.com/vulnerability-list/year-2007/month-1/January.html


# In[3]:


len(nvddata[nvddata.cvss_scorev3 != "nov3"])


# ## Data cleaning lines

# In[4]:


targetdata.fillna(0, inplace=True)
# nvddata.cvss_scorev3.replace(to_replace=["CVSS:3.1","CVSS:3.0"],value="nov3",inplace=True)
cwe_patterns=cwe_patterns.iloc[:,[0,6,21]]


# In[5]:


#open sour e vulnerablity database data
nvddata.head(10)


# In[6]:


# CWE CAPECA data
cwe_patterns.head(10)


# In[7]:


# reconnassiance synthetic data
threatdata.head(10)


# In[8]:


targetdata.head(10)


# 

# # Probablity calculation formula from ("Vulnerblity Connectivity") by Heng Wei Zhang

# In[9]:


def Vulenerablity_connector(vec):
    if vec != "nov3":
        v3=vec.split('/')
        v3_dic={ x.split(':')[0]:x.split(':')[1] for x in v3 }
        
        # this values are taken form cvss 3.1 metric score table
        # Attack Vector = N=0.85 A=0.62 L=0.55 P=0.22
        # Attack Complexity = H=0.77 L=0.44
        # Priviledges Required N=0.85 scope changed(L=0.68,H=0.5) or scope not changed(L=0.62,H=0.27)
        # scope C is changed and U is not changed
        
        # math. sqrt(x)
        av_value={"N":0.85, "A":0.62 ,"L":0.55 ,"P":0.22}
        ac_value={"H":0.77, "L":0.44 }
        pr_value={ "C":{"L":0.68,"H":0.5, "N":0.85,}, "U":{"L":0.62,"H":0.27, "N":0.85,}}
        
        probablity=(pr_value[v3_dic["S"]][v3_dic["PR"]]/(pr_value[v3_dic["S"]][v3_dic["PR"]]+math.sqrt(av_value[v3_dic["AV"]]*ac_value[v3_dic["AC"]])))
        

        return probablity
    return "unknown"
nvddata["Vulnerablity_connector"]=nvddata.cvss_scorev3.map(Vulenerablity_connector)


# # Scanning result filter and miscellaneous functions

# In[10]:


# this is target version,os and device list
#//////////////////////////////////////////////////////
ver=targetdata.version.unique()
os=targetdata.OSInfo.unique()
os=[x for x in os if x != 0]
dev=targetdata.Device.unique()
dev=[x for x in dev if x != 0]
#/////////////////////////////////////////////////////////
# this is threat version,os and device list
# /////////////////////////////////////////////////////
th_ver=threatdata.version.unique()
th_os=threatdata.OSInfo.unique()
th_os=[x for x in th_os if x != 0]
th_dev=threatdata.Device.unique()
th_dev=[x for x in th_dev if x != 0]
# /////////////////////////////////////////////////////////////////
# This is target session filter
# ///////////////////////////////////////
def test_target_service(description):
    if re.search(f'({"|".join(os)})',description):
        return True
    return False
      
def test_target_device(description):

    if re.search(f'({"|".join(dev)})',description):
        return True
    return False
    
def test_target_version(description):
     if re.search(f'({"|".join(ver)})',description):
          return True
     return False
# ////////////////////////////////////////
# This is threat source version filter
# /////////////////////////////////////////////
def test_threat_service(description):
    if re.search(f'({"|".join(th_os)})',description):
        return True
    return False
      
def test_threat_device(description):

    if re.search(f'({"|".join(th_dev)})',description):
        return True
    return False
    
def test_threat_version(description):
     if re.search(f'({"|".join(th_ver)})',description):
          return True
     return False
# ///////////////////////////////////////////////////////
#scoring func### Availablity Severity distributioniton
# /////////////////////////////////////////////////////
def cvs3_sc(vector):
    score=CVSS3(vector)
    return score.scores()[0]
#distribution function
#this catagoraizaitn is based on CVSS3 specification table
# //////////////////////////////////////////////////////
def compare(score):
    if score == 0:
        return "None"
    elif 0.1 <= score <= 3.9:
        return "Low"
    elif 4<= score <=6.9:
        return "Medium"
    elif 7<=score<=8.9:
        return "High"
    elif 9<=score<=10:
        return "Critical"
  
#   /////////////////////////////////////////////////// 


# # Filtering Possible CVEs in target and threat source

# In[11]:



# Running Filter Map functions for target
#  ///////////////////////////////
# please note that order maters here when executing
nvddata['target_possible_v']=nvddata.description.map(test_target_version)
nvddata['target_possible_s']=nvddata.description.map(test_target_service)
nvddata['target_possible_dev']=nvddata.description.map(test_target_device)

# Running Filter Map functions for threat source
#  ///////////////////////////////
# please note that order maters here when executing
nvddata['threat_possible_v']=nvddata.description.map(test_threat_version)
nvddata['threat_possible_s']=nvddata.description.map(test_threat_service)
#nvddata['threat_possible_dev']=nvddata.description.map(test_threat_device)

target_cves=nvddata[(nvddata.target_possible_v == True) | (nvddata.target_possible_s == True) | (nvddata.target_possible_dev == True) ]
threat_cves=nvddata[(nvddata.threat_possible_v == True) | (nvddata.threat_possible_s == True)]


# # Generating The List

# In[12]:



target_list_with_nov3=target_cves[target_cves.cvss_scorev3 == "nov3"]
target_list_with_score=target_cves[target_cves.cvss_scorev3 != "nov3"]
threat_list_with_nov3=threat_cves[threat_cves.cvss_scorev3 == "nov3"]
threat_list_with_score=threat_cves[threat_cves.cvss_scorev3 != "nov3"]


# In[13]:


len(target_cves)


# In[14]:


len(threat_cves)


# ### Combination of the lists

# In[15]:


#genarated_combination
genarated_combination=list(product(threat_list_with_score.cve_number,target_list_with_score.cve_number))
chained_list=pd.DataFrame({'threat_target':genarated_combination},columns=['threat_target'])


# In[16]:


print(f"length of target cve is : {len(target_list_with_score.cve_number)}")
print(f"length of threat cve is : {len(threat_list_with_score.cve_number)}")


# In[17]:


# dictionary of connector,score and cwe id 
nvd_score_dic=dict(zip(nvddata.cve_number,nvddata.cvss_scorev3))
connector_dic=dict(zip(nvddata['cve_number'],nvddata['Vulnerablity_connector']))
cweid_dic=dict(zip(nvddata['cve_number'],nvddata['cwe_number']))


# In[18]:




#calculating combined vulnerablity connectivity probablity
def combined_connector(v3):
    return connector_dic[v3[0]]*connector_dic[v3[1]]

#connectivity operator as per zhang
def zhang_connectivity_op(th_targ):
        v3t=nvd_score_dic.get(th_targ[0])
        v3targ=nvd_score_dic.get(th_targ[1])
        v3t_dic={ x.split(':')[0]:x.split(':')[1] for x in v3t.split('/') }
        v3targ_dic={ x.split(':')[0]:x.split(':')[1] for x in v3targ.split('/') }
        av_value={"N":0.85, "A":0.62 ,"L":0.55 ,"P":0.22}
        ac_value={"H":0.77, "L":0.44 }
        pr_value={ "C":{"L":0.68,"H":0.5, "N":0.85,}, "U":{"L":0.62,"H":0.27, "N":0.85,}}
        
        probablity=pr_value[v3t_dic["S"]][v3t_dic["PR"]]/(pr_value[v3t_dic["S"]][v3t_dic["PR"]]+math.sqrt(ac_value[v3t_dic["AC"]]*av_value[v3targ_dic["AV"]]))

        return probablity
        #probablity=(pr_value[v3_dic["S"]][v3_dic["PR"]]/(pr_value[v3_dic["S"]][v3_dic["PR"]]+math.sqrt(av_value[v3_dic["AV"]]*ac_value[v3_dic["AC"]])))


#calculating chainned score
def combined_chainned_score(v3):
    
        if nvd_score_dic.get(v3[0]):
            threat_lis=nvd_score_dic.get(v3[0]).split('/')
        if nvd_score_dic.get(v3[1]):    
            target_lis=nvd_score_dic.get(v3[1]).split('/')
        if nvd_score_dic.get(v3[1]) and nvd_score_dic.get(v3[0]): 
            threat={x.split(':')[0]:x.split(':')[1]  for x in threat_lis}
            target={x.split(':')[0]:x.split(':')[1]  for x in target_lis}
            
            # this values are taken form cvss 3.1 metric score table
            # Attack Vector = N=0.85 A=0.62 L=0.55 P=0.22
            # confidentiality/Integerity/Availablity H=0.56,L=0.22,N=0
            # User Interaction N=0.85 R=0.62
            # Attack Complexity = H=0.77 L=0.44
            # Priviledges Required N=0.85 scope changed(L=0.68,H=0.5) or scope not changed(L=0.62,H=0.27)
            #print(threat)
            
            scope=threat['S']
            if threat['S'] != target['S']:
                scope="C"
            
            ui=threat['UI']
            if threat['UI'] != target['UI']:
                ui="N"
            
            ac=threat['AC']
            if threat['AC'] != target['AC']:
                ac="H"
            

            if threat['C'] == "H" or target['C'] == "H":
                conf="H"
            elif threat['C'] == "L" or target['C'] == "L" and (threat['C'] != "H" or target['C'] != "H"):
                conf="L"
            else:
                conf="N"

            if threat['I'] == "H" or target['I'] == "H":
                integ="H"
            elif threat['I'] == "L" or target['I'] == "L" and (threat['I'] != "H" or target['I'] != "H"):
                integ="L"
            else:
                integ="N"

            if threat['A'] == "H" or target['A'] == "H":
                avail="H"
            elif threat['A'] == "L" or target['A'] == "L" and (threat['A'] != "H" or target['A'] != "H"):
                avail="L"
            else:
                avail="N"
            
            if threat['PR'] == "N" or target['PR'] == "N":
                pr="N"
            elif threat['PR'] == "L" or target['PR'] == "L" and (threat['PR'] != "N" or target['PR'] != "N"):
                pr="L"
            else:
                pr="H"
            
            #NALP
            if threat['AV'] == "N" or target['AV'] == "N":
                av="N"
            elif threat['AV'] == "A" or target['AV'] == "A" and (threat['AV'] != "N" or target['AV'] != "N"):
                av="A"
            elif threat['AV'] == "L" or target['AV'] == "L" and (threat['AV'] != "A" or target['AV'] != "A" or threat['AV'] != "N" or target['AV'] != "N"):
                av="L"
            else:
                av="P"
            
            chained_vector= f"CVSS:3.1/AV:{av}/AC:{ac}/PR:{pr}/UI:{ui}/S:{scope}/C:{conf}/I:{integ}/A:{avail}"
            
            #
            return CVSS3(chained_vector).scores()[0]
            #return chained_vector
        else:
            return "unkown"
      
     

#checking related weakness from the CWE related pattern list
cwe_patterns.Related_Attack_Patterns.fillna("nothing",inplace=True)
def cwe_related_patterns(h):

    if h != "nothing":
        return h.strip().split("::")
cwe_patterns['related_list']=cwe_patterns.Related_Attack_Patterns.map(cwe_related_patterns)
pattern_litmus_dic=dict(zip(cwe_patterns.CWE_ID,cwe_patterns.related_list))
def checking_related_pattern(vec):
   
    if cweid_dic.get(vec[0]) or cweid_dic.get(vec[1]):
        if  cweid_dic.get(vec[0]) in cweid_dic.get(vec[1])  or cweid_dic.get(vec[1]) in cweid_dic.get(vec[0]):
            return "probable relation"
        return "no information"
        
    return "no information"


# In[19]:


chained_list['vulnerablity_connector']=chained_list.threat_target.map(combined_connector)
chained_list['cvssv3_chained_score']=chained_list.threat_target.map(combined_chainned_score)
chained_list['relation_for_chainning']=chained_list.threat_target.map(checking_related_pattern)
# chained_list["zhang_connector"]=chained_list.threat_target.map(combined_connector)


# In[20]:


# chained_list["zhang_connector"]=chained_list.threat_target.map(zhang_connectivity_op)


# # Finally Generated csv file List

# In[21]:


def target_source_av(v3):
    if nvd_score_dic.get(v3[0]):
        threat_lis=nvd_score_dic.get(v3[0]).split('/')
    if nvd_score_dic.get(v3[1]):    
        target_lis=nvd_score_dic.get(v3[1]).split('/')
    if nvd_score_dic.get(v3[1]) and nvd_score_dic.get(v3[0]): 
        threat={x.split(':')[0]:x.split(':')[1]  for x in threat_lis}
        target={x.split(':')[0]:x.split(':')[1]  for x in target_lis}
    return f"{threat['AV']}-{target['AV']}"

def filter_source_target_logic(x):
    if x.split('-')[0] == "P" or x.split('-')[1] == "P"  or x =="A-A": 
        return False;
    return True
chained_list['av_source_target']=chained_list.threat_target.map(target_source_av)
chained_list['chain_logic']=chained_list.av_source_target.map(filter_source_target_logic)
        


# In[22]:


# filtering with chainlogic values
chained_list=chained_list[chained_list.chain_logic == True] 
chained_list.drop('chain_logic',1)
print('nothing')


# In[23]:


#simple spliting funcitons
def source_split(x):
    return x[0]
def target_split(x):
     return x[1]
def compare(score):
    if score == 0:
        return "None"
    elif 0.1 <= score <= 3.9:
        return "Low"
    elif 4<= score <=6.9:
        return "Medium"
    elif 7<=score<=8.9:
        return "High"
    elif 9<=score<=10:
        return "Critical"

chained_list['severity']=chained_list.cvssv3_chained_score.map(compare)
chained_list['source_cve']=chained_list.threat_target.map(source_split)
chained_list['target_cve']=chained_list.threat_target.map(target_split)


# # Sections following are sample ways of using generated list

# In[24]:


chained_list.vulnerablity_connector.describe()


# In[25]:


chained_list.cvssv3_chained_score.describe()


# In[26]:


chained_list.head(5)


# In[27]:


target_weakness=chained_list.groupby(['target_cve'])['severity'].value_counts().reset_index(name='severity_counts')
target_weakness.head(10)


# In[28]:


# target_weakness_normalized=chained_list.groupby(['target_cve'])['severity'].value_counts(normalize=True).reset_index(name='severity_weights')
# target_weakness_normalized.head(10)
twn=chained_list.groupby(['target_cve'])['severity'].value_counts(normalize=True)


# In[29]:


twn


# In[30]:


cwd=dict(zip(twn.index,twn.values))


# In[31]:


# target_weakness_connector=chained_list.groupby(['target_cve','severity'])['vulnerablity_connector'].mean().sort_values(ascending=False)
twc=chained_list.groupby(['target_cve','severity'])['vulnerablity_connector'].mean()


# In[32]:


vcd=dict(zip(twc.index,twc.values))


# In[33]:


tv3s=chained_list.groupby(['target_cve','severity'])['cvssv3_chained_score'].mean()
# tv3s=chained_list.groupby(['target_cve'])['cvssv3_chained_score'].mean()
tv3s


# In[34]:


# chained_list.groupby


# In[35]:


smd=dict(zip(tv3s.index,tv3s.values))


# In[36]:


ptc=chained_list.groupby('target_cve')['relation_for_chainning'].value_counts()


# In[37]:


ptcd=dict(zip(ptc.index,ptc.values))


# In[38]:


final_product=pd.DataFrame({'target_cve':chained_list.target_cve.unique()})

def weighted_average_connectivity(x):
    s=["High","Medium","Low","Critical"]
    return ((twc.get((x,s[0]),0)*twn.get((x,s[0]),0))+(twc.get((x,s[1]),0)*twn.get((x,s[1]),0))+(twc.get((x,s[2]),0)*twn.get((x,s[2]),0))+(twc.get((x,s[3]),0)*twn.get((x,s[3]),0)))/(twn.get((x,s[0]),0)+twn.get((x,s[1]),0)+twn.get((x,s[2]),0)+twn.get((x,s[3]),0))
    
def average_v3_score(x):
    s=["High","Medium","Low","Critical"]
    return ((smd.get((x,s[0]),0)*twn.get((x,s[0]),0))+(smd.get((x,s[1]),0)*twn.get((x,s[1]),0))+(smd.get((x,s[2]),0)*twn.get((x,s[2]),0))+(smd.get((x,s[3]),0)*twn.get((x,s[3]),0)))/(twn.get((x,s[0]),0)+twn.get((x,s[1]),0)+twn.get((x,s[2]),0)+twn.get((x,s[3]),0))
def pattern_count(x):
    return ptcd.get((x,"probable relation"),0)

final_product['average_connectivity']=final_product.target_cve.map(weighted_average_connectivity)
final_product['average_cvss3_score']=final_product.target_cve.map(average_v3_score)
final_product['relation_count']=final_product.target_cve.map(pattern_count)


# In[39]:


plt.title("cwe realtion count distribution in target")
sns.violinplot(final_product.relation_count)
plt.savefig('relationcount.png')


# In[40]:


plt.title("vulnerablitiy connectivity distribution in target")
sns.violinplot(final_product.average_connectivity)
plt.savefig('acon_frequencey.png')


# In[41]:


plt.title("CVSS v3 chainned score distribution in target")
sns.violinplot(final_product.average_cvss3_score)
plt.savefig('av3socre_frequencey.png')


# In[42]:


#maximum vulnerablity connectivity can assume
def max_connectivity(x):
    return x/(x+math.sqrt(0.2*0.44))
gt=np.arange(0.27, 0.85, 0.01)
plt.plot(gt, max_connectivity(gt),'r--')


# In[43]:


#minimum vulnerablity connectitivity can assume
def min_connectivity(x):
    return x/(x+math.sqrt(0.77*0.85))
gt=np.arange(0.27, 0.85, 0.01)
plt.plot(gt, min_connectivity(gt),'r--')


# In[44]:


# Max connector value
print(0.85/(0.85+math.sqrt(0.2*0.44))) # max connectivity value 


# In[45]:


#min cinnector value
print(0.27/(0.27+math.sqrt(0.7*0.85))) # min connectivity value


# # Below is exporting chained list with cvss scores and vulnerablity_connectivity scores

# In[46]:


# data with scores and that do not have "Physical" Attack vector value in the target node 
final_product.head(10)


# In[47]:


# data that have "Physical" Attack vector value in the target node 

def filter_physical(x):
    sam=x.split("/")
    test_dic={x.split(':')[0]:x.split(':')[1] for x in sam}
    if test_dic.get('AV',None)=="P":
        return True
    return False
targ_pd=pd.DataFrame({'cve_number':target_list_with_score.cve_number,'cvss_vector':target_list_with_score.cvss_scorev3},columns=['cve_number','cvss_vector'])

targ_pd["physical"]=targ_pd.cvss_vector.map(filter_physical)
# targ_pd['base_score']=targ_pd.cvss_vector.map(cvs3_sc)
targ_pd[targ_pd.physical != False]
# print(CVSS3('CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H').scores()[0])


# In[48]:


# weakness in target node with no CVSS scores
target_list_with_nov3.iloc[:,[0,3]].head(10)


# # Some Numeric Evaluation of Results

# In[49]:


print(f"length of target cve is : {len(target_cves.cve_number)}")
print(f"length of threat cve is : {len(threat_cves.cve_number)}")
print(f"length of target cve with cvss scores is : {len(target_list_with_score.cve_number)}")
print(f"length of threat cve with cvss scores is : {len(threat_list_with_score.cve_number)}")


# In[50]:


len(genarated_combination)
# genarated_combination=list(product(threat_list_with_score.cve_number,target_list_with_score.cve_number))

# three_stage_threat_path=(list(product(threat_list_with_score.cve_number,threat_list_with_score.cve_number,target_list_with_score.cve_number)))
three_stage_threat_path=(list(product(threat_list_with_score.cve_number,threat_list_with_score.cve_number,target_list_with_score.cve_number)))
print(f" The single stage paths that can be formed are  {len(genarated_combination)}")
print(f" The three stage paths that can be formed are  {len(three_stage_threat_path)}") # if multistage path generation for risk assessment was employed


# In[51]:


len(final_product[final_product.average_cvss3_score > 4])


# In[52]:


# interms of performance of the approach
# real explotion should be conducted and compare results 


# # Finally Exporting to CSV

# In[53]:


# exporting to cvss
# final_product.to_csv("finalproduct.csv",index=False,encoding="utf-8")


# 
